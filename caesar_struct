struct CaesarCipher {
    shift: usize,
}

impl CaesarCipher {
    fn new(shift: usize) -> Self {
        Self { shift }
    }

    fn encrypt(&self, plain_text: &str) -> String {
        let mut cipher_text = String::new();
        for c in plain_text.chars() {
            let shifted_char = match c {
                'A'..='Z' => {
                    let base = 'A' as u8;
                    (((c as u8 - base + self.shift as u8) % 26) + base) as char
                }
                'a'..='z' => {
                    let base = 'a' as u8;
                    (((c as u8 - base + self.shift as u8) % 26) + base) as char
                }
                _ => c,
            };
            cipher_text.push(shifted_char);
        }
        cipher_text
    }

    fn decrypt(&self, cipher_text: &str) -> String {
        let mut plain_text = String::new();
        for c in cipher_text.chars() {
            let shifted_char = match c {
                'A'..='Z' => {
                    let base = 'A' as u8;
                    (((c as u8 - base + 26 - self.shift as u8) % 26) + base) as char
                }
                'a'..='z' => {
                    let base = 'a' as u8;
                    (((c as u8 - base + 26 - self.shift as u8) % 26) + base) as char
                }
                _ => c,
            };
            plain_text.push(shifted_char);
        }
        plain_text
    }
}

fn main() {
    let cipher = CaesarCipher::new(3);
    let plaintext = "Hello, world!";
    let ciphertext = cipher.encrypt(plaintext);
    let decrypted = cipher.decrypt(&ciphertext);
    println!("Plaintext: {}", plaintext);
    println!("Ciphertext: {}", ciphertext);
    println!("Decrypted: {}", decrypted);
}
